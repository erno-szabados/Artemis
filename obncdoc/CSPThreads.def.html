<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
	<head>
		<meta name='viewport' content='width=device-width, initial-scale=1.0' />
		<meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
		<title>DEFINITION CSPThreads</title>
		<link rel='stylesheet' type='text/css' href='style.css' />
	</head>
	<body>
		<p><a href='index.html'>Index</a></p>

		<pre>
<span class='comment'>(*
    CSPThreads.Mod - Thread-safe channels and threading utilities for Oberon-07
    
    Provides:
    - Thread-safe buffered channels with blocking/non-blocking operations
    - Basic thread creation and management using PThreads
    - Clean CSP-style communication primitives
    
    THREAD SAFETY ARCHITECTURE:
    
    This module uses a safe thread procedure registry to eliminate memory safety
    issues when passing Oberon procedure pointers to C pthread functions.
    
    Problem: pthread_create() expects a C function pointer, but we need to call
    Oberon procedures. The naive approach of casting procedure pointers to integers
    using SYSTEM.VAL() is unsafe and can cause crashes.
    
    Solution: Thread Procedure Registry
    - HashMap-based registry maps safe integer IDs to procedure pointers
    - ThreadTrampoline() uses the ID to safely lookup the actual procedure
    - Automatic cleanup when threads complete (both normal and joined)
    - Thread-safe operations protected by mutex
    - No arbitrary thread limits (grows dynamically with available memory)
    
    Flow:
    1. NewThread(proc) → RegisterThreadProc(proc) → returns safe integer ID
    2. pthread_create(ThreadTrampoline, ID) → creates OS thread with safe ID
    3. ThreadTrampoline(ID) → GetThreadProc(ID) → calls actual procedure
    4. Thread completion → UnregisterThreadProc(ID) → cleanup registry entry
    
    This approach provides complete memory safety while maintaining clean CSP semantics.
    
    Copyright (C) 2025
    Released under The 3-Clause BSD License.
    Author: Artemis Project
*)</span>
DEFINITION <em>CSPThreads</em>;

IMPORT Collections;

CONST
    OPEN = 0;
    CLOSED = 1;

TYPE
    <span class='comment'>(* Thread-safe buffered channel for message passing between threads *)</span>
    BufferedChannel = POINTER TO BufferedChannelDesc;

    <span class='comment'>(* Thread-safe synchronous channel for rendezvous communication *)</span>
    SyncChannel = POINTER TO SyncChannelDesc;

    <span class='comment'>(* Thread procedure signature *)</span>
    ThreadProc = PROCEDURE;

    <span class='comment'>(* Thread handle for managing OS threads *)</span>
    Thread = POINTER TO ThreadDesc;

<span class='comment'>(* Free buffered channel resources - call when done with channel *)</span>
PROCEDURE <em>FreeBufferedChannel</em>(VAR ch: BufferedChannel);

<span class='comment'>(* Create a new thread-safe buffered channel with specified buffer capacity *)</span>
PROCEDURE <em>NewBufferedChannel</em>(capacity: INTEGER): BufferedChannel;

<span class='comment'>(* Close a buffered channel - no more sends allowed, receives drain remaining messages *)</span>
PROCEDURE <em>CloseBufferedChannel</em>(ch: BufferedChannel);

<span class='comment'>(* Check if buffered channel is closed *)</span>
PROCEDURE <em>IsBufferedClosed</em>(ch: BufferedChannel): BOOLEAN;

<span class='comment'>(* Non-blocking send - returns TRUE if message was sent, FALSE if buffer full or error *)</span>
PROCEDURE <em>TrySend</em>(ch: BufferedChannel; item: Collections.ItemPtr): BOOLEAN;

<span class='comment'>(* Non-blocking receive - returns TRUE if message received, FALSE if buffer empty or error *)</span>
PROCEDURE <em>TryReceive</em>(ch: BufferedChannel; VAR item: Collections.ItemPtr): BOOLEAN;

<span class='comment'>(* Blocking send - waits until message can be sent or buffered channel is closed *)</span>
PROCEDURE <em>Send</em>(ch: BufferedChannel; item: Collections.ItemPtr);

<span class='comment'>(* Blocking receive - waits until message available or buffered channel closed and empty *)</span>
PROCEDURE <em>Receive</em>(ch: BufferedChannel; VAR item: Collections.ItemPtr);

<span class='comment'>(* Create and start a new thread *)</span>
PROCEDURE <em>NewThread</em>(proc: ThreadProc): Thread;

<span class='comment'>(*
    Wait for thread to complete
    
    Note: We use a dual cleanup strategy for registry entries:
    1. Normal cleanup in ThreadTrampoline when thread completes normally
    2. Safety cleanup here in case the thread didn't complete normally
    This ensures no registry entries are leaked regardless of thread fate.
*)</span>
PROCEDURE <em>JoinThread</em>(thread: Thread): BOOLEAN;

<span class='comment'>(* 
   Synchronous Channel Operations
   
   True CSP-style synchronous communication with rendezvous semantics.
   Sender and receiver block until both are ready, then handoff occurs directly.
 *)</span>

<span class='comment'>(* Free synchronous channel resources *)</span>
PROCEDURE <em>FreeSyncChannel</em>(VAR ch: SyncChannel);

<span class='comment'>(* Close a synchronous channel - no more operations allowed *)</span>
PROCEDURE <em>CloseSyncChannel</em>(ch: SyncChannel);

<span class='comment'>(* Create a new synchronous channel for rendezvous communication *)</span>
PROCEDURE <em>NewSyncChannel</em>(): SyncChannel;

<span class='comment'>(* Check if synchronous channel is closed *)</span>
PROCEDURE <em>IsSyncClosed</em>(ch: SyncChannel): BOOLEAN;

<span class='comment'>(* Non-blocking synchronous send - returns TRUE only if receiver ready *)</span>
PROCEDURE <em>TrySyncSend</em>(ch: SyncChannel; item: Collections.ItemPtr): BOOLEAN;

<span class='comment'>(* Non-blocking synchronous receive - returns TRUE only if sender ready *)</span>
PROCEDURE <em>TrySyncReceive</em>(ch: SyncChannel; VAR item: Collections.ItemPtr): BOOLEAN;

<span class='comment'>(* Blocking synchronous send - waits for receiver rendezvous *)</span>
PROCEDURE <em>SyncSend</em>(ch: SyncChannel; item: Collections.ItemPtr);

<span class='comment'>(* Blocking synchronous receive - waits for sender rendezvous *)</span>
PROCEDURE <em>SyncReceive</em>(ch: SyncChannel; VAR item: Collections.ItemPtr);

PROCEDURE <em>Init</em>();

END CSPThreads.
</pre>
	</body>
</html>
