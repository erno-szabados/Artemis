(**
    artPThread.obn - POSIX threads wrapper for OBNC
    
    Provides basic pthread functionality for CSP implementation.
    
    Copyright (C) 2025
    Released under The 3-Clause BSD License.
*)
MODULE artPThread;

CONST
    Ok* = 0;  (** Operation successful *)
    InvalidHandle* = 1;  (** Invalid handle or pointer *)
    Deadlock* = 2;  (** Deadlock detected *)
    ResourceExhausted* = 3;  (** Out of resources *)
    NotOwner* = 4;  (** Not owner of mutex *)
    Busy* = 5;  (** Resource busy *)
    MaxRecursion* = 7;      (** Maximum recursion exceeded (EAGAIN) *)
    NotRecoverable* = 8;    (** State not recoverable (ENOTRECOVERABLE) *)
    OwnerDead* = 9;         (** Previous owner died (EOWNERDEAD) *)
    Timeout* = 10;          (** Timed out (ETIMEDOUT, for condvar timed wait) *)
    UnknownError* = 100;  (** Unknown or unexpected error *)

TYPE
    (** Opaque mutex type *)
    Mutex* = POINTER TO MutexDesc;
    MutexDesc = RECORD
        handle: INTEGER  (* Will hold pthread_mutex_t pointer *)
    END;
    
    (** Opaque condition variable type *)
    CondVar* = POINTER TO CondVarDesc;
    CondVarDesc = RECORD
        handle: INTEGER  (* Will hold pthread_cond_t pointer *)
    END;
    
    (** Opaque thread type *)
    Thread* = POINTER TO ThreadDesc;
    ThreadDesc = RECORD
        handle: INTEGER  (* Will hold pthread_t *)
    END;

    (** Pointer to a Thread Procedure, taking a SYSTEM.ADR and returning a SYSTEM.ADR void* -> void* *)
    ThreadProc* = PROCEDURE(contextPtr: INTEGER): INTEGER;

(** Create a new mutex *)
PROCEDURE NewMutex*(): Mutex;
BEGIN
    (* Formal body, C implementation takes precedence. *)
    RETURN NIL
END NewMutex;

(** Destroy a mutex *)
PROCEDURE FreeMutex*(VAR mutex: Mutex);
BEGIN
    (* Formal body, C implementation takes precedence. *)
END FreeMutex;

(** Lock a mutex (blocking)
    Returns Ok, Deadlock, InvalidHandle, or UnknownError. *)
PROCEDURE Lock*(mutex: Mutex): INTEGER;
BEGIN
    (* Formal body, C implementation takes precedence. *)
    RETURN UnknownError
END Lock;

(** Unlock a mutex
    Returns Ok, NotOwner, InvalidHandle, or UnknownError. *)
PROCEDURE Unlock*(mutex: Mutex): INTEGER;
BEGIN
    (* Formal body, C implementation takes precedence. *)
    RETURN UnknownError
END Unlock;

(** Try to lock a mutex (non-blocking)
    Returns Ok, Busy, InvalidHandle, or UnknownError. *)
PROCEDURE TryLock*(mutex: Mutex): INTEGER;
BEGIN
    (* Formal body, C implementation takes precedence. *)
    RETURN UnknownError
END TryLock;

(** Create a new condition variable *)
PROCEDURE NewCondVar*(): CondVar;
BEGIN
    (* Formal body, C implementation takes precedence. *)
    RETURN NIL
END NewCondVar;

(** Destroy a condition variable *)
PROCEDURE FreeCondVar*(VAR cv: CondVar);
BEGIN
    (* Formal body, C implementation takes precedence. *)
END FreeCondVar;

(** Wait on a condition variable (releases mutex, reacquires on wake)
    Returns Ok, InvalidHandle, or UnknownError. *)
PROCEDURE Wait*(cv: CondVar; mutex: Mutex): INTEGER;
BEGIN
    (* Formal body, C implementation takes precedence. *)
    RETURN UnknownError
END Wait;

(** Signal one waiting thread
    Returns Ok, InvalidHandle, or UnknownError. *)
PROCEDURE Signal*(cv: CondVar): INTEGER;
BEGIN
    (* Formal body, C implementation takes precedence. *)
    RETURN UnknownError
END Signal;

(** Signal all waiting threads
    Returns Ok, InvalidHandle, or UnknownError. *)
PROCEDURE Broadcast*(cv: CondVar): INTEGER;
BEGIN
    (* Formal body, C implementation takes precedence. *)
    RETURN UnknownError
END Broadcast;

(** Create a new thread *)
PROCEDURE NewThread*(proc: ThreadProc; context : INTEGER): Thread;
BEGIN
    (* Formal body, C implementation takes precedence. *)
    RETURN NIL
END NewThread;

(** Wait for thread to finish
    Returns Ok, InvalidHandle, or UnknownError. *)
PROCEDURE Join*(thread: Thread): INTEGER;
BEGIN
    (* Formal body, C implementation takes precedence. *)
    RETURN UnknownError
END Join;

(** Sleep for milliseconds *)
PROCEDURE Sleep*(ms: INTEGER);
BEGIN
    (* Formal body, C implementation takes precedence. *)
END Sleep;

END artPThread.
