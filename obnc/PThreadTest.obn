(**
    PThreadTest.Mod - Unit tests for MINIMAL artPThread module
    
    Copyright (C) 2025
    Released under The 3-Clause BSD License.
*)
MODULE PThreadTest;

IMPORT Tests, artPThread, Out, Clock := artClock;

VAR
    ts: Tests.TestSet;
    threadRan: BOOLEAN;

PROCEDURE TestSleep(): BOOLEAN;
VAR pass : BOOLEAN;
    c : Clock.Clock;
BEGIN
    pass := TRUE;
    NEW(c);
    Clock.Get(c);
    Out.String("  TestSleep (s):"); Out.Int(c.minute, 0); Out.String(":"); Out.Int(c.second, 0); Out.Ln;
    
    Out.String("Sleeping for 2 seconds..."); Out.Ln;
    (* Simple test: Sleep should not crash and should take some time *)
    artPThread.Sleep(2000); (* Sleep for 10 milliseconds *)
    
    Clock.Get(c);
    Out.String("  TestSleep (s):"); Out.Int(c.minute, 0); Out.String(":"); Out.Int(c.second, 0); Out.Ln;
    
    (* Test with zero - should not crash *)
    artPThread.Sleep(0);
    
    (* Test with negative - should not crash *)
    artPThread.Sleep(-1);
    
    (* This test primarily checks if the call can be made without crashing *)
    Tests.ExpectedBool(TRUE, TRUE, "Sleep function calls completed", pass);
    RETURN pass
END TestSleep;

PROCEDURE TestMutex(): BOOLEAN;
VAR pass, result: BOOLEAN;
    mutex: artPThread.Mutex;
BEGIN
    pass := TRUE;
    Out.String("  TestMutex...");
    
    (* Test mutex creation *)
    mutex := artPThread.NewMutex();
    Tests.ExpectedBool(FALSE, mutex = NIL, "Mutex creation should succeed", pass);
    
    IF mutex # NIL THEN
        (* Test locking *)
        result := artPThread.Lock(mutex);
        Tests.ExpectedBool(TRUE, result, "Mutex lock should succeed", pass);
        
        (* Test unlocking *)
        result := artPThread.Unlock(mutex);
        Tests.ExpectedBool(TRUE, result, "Mutex unlock should succeed", pass);
        
        (* Test double lock/unlock *)
        result := artPThread.Lock(mutex);
        Tests.ExpectedBool(TRUE, result, "Second mutex lock should succeed", pass);
        
        result := artPThread.Unlock(mutex);
        Tests.ExpectedBool(TRUE, result, "Second mutex unlock should succeed", pass);
        
        (* Test TryLock on unlocked mutex *)
        result := artPThread.TryLock(mutex);
        Tests.ExpectedBool(TRUE, result, "TryLock should succeed on unlocked mutex", pass);

        (* Test TryLock on already locked mutex *)
        result := artPThread.TryLock(mutex);
        Tests.ExpectedBool(FALSE, result, "TryLock should fail on already locked mutex", pass);

        (* Unlock for cleanup *)
        result := artPThread.Unlock(mutex);
        Tests.ExpectedBool(TRUE, result, "Unlock after TryLock should succeed", pass);
        
        (* Clean up *)
        artPThread.FreeMutex(mutex);
        Tests.ExpectedBool(TRUE, mutex = NIL, "Mutex should be NIL after FreeMutex", pass)
    END;
    
    IF pass THEN Out.String(" OK") ELSE Out.String(" FAILED") END; Out.Ln;
    RETURN pass
END TestMutex;

PROCEDURE TestCondVar(): BOOLEAN;
VAR pass: BOOLEAN;
    cv: artPThread.CondVar;
BEGIN
    pass := TRUE;
    Out.String("  TestCondVar...");
    
    (* Test condvar creation *)
    cv := artPThread.NewCondVar();
    Tests.ExpectedBool(FALSE, cv = NIL, "CondVar creation should succeed", pass);
    
    IF cv # NIL THEN
        (* Clean up *)
        artPThread.FreeCondVar(cv);
        Tests.ExpectedBool(TRUE, cv = NIL, "CondVar should be NIL after FreeCondVar", pass)
    END;
    
    IF pass THEN Out.String(" OK") ELSE Out.String(" FAILED") END; Out.Ln;
    RETURN pass
END TestCondVar;

PROCEDURE TestCondVarWaitSignal(): BOOLEAN;
VAR pass, ok: BOOLEAN;
    mutex: artPThread.Mutex;
    cv: artPThread.CondVar;
    signaled: BOOLEAN;
BEGIN
    pass := TRUE;
    Out.String("  TestCondVarWaitSignal...");
    
    mutex := artPThread.NewMutex();
    cv := artPThread.NewCondVar();
    signaled := FALSE;
    
    IF (mutex # NIL) & (cv # NIL) THEN
        ok := artPThread.Lock(mutex);
        Tests.ExpectedBool(TRUE, ok, "Lock before wait should succeed", pass);
        
        (* In a real test, another thread would Signal. Here, we just check that Wait returns 1 if signaled. *)
        (* This is a placeholder for a real concurrent test. *)
        ok := artPThread.Signal(cv);
        Tests.ExpectedBool(TRUE, ok, "Signal should succeed", pass);
        
        ok := artPThread.Wait(cv, mutex);
        Tests.ExpectedBool(TRUE, ok, "Wait should succeed (no real wait)", pass);
        
        ok := artPThread.Unlock(mutex);
        Tests.ExpectedBool(TRUE, ok, "Unlock after wait should succeed", pass);
        
        artPThread.FreeCondVar(cv);
        artPThread.FreeMutex(mutex);
    ELSE
        pass := FALSE;
    END;
    
    IF pass THEN Out.String(" OK") ELSE Out.String(" FAILED") END; Out.Ln;
    RETURN pass
END TestCondVarWaitSignal;


PROCEDURE ThreadProc(context: INTEGER): INTEGER;
BEGIN
    threadRan := TRUE;
    RETURN 0
END ThreadProc;

PROCEDURE TestThread(): BOOLEAN;
VAR pass, ok: BOOLEAN;
    t: artPThread.Thread;
BEGIN
    pass := TRUE;
    Out.String("  TestThread...");
    threadRan := FALSE;
    t := artPThread.NewThread(ThreadProc);
    Tests.ExpectedBool(FALSE, t = NIL, "Thread creation should succeed", pass);
    IF t # NIL THEN
        ok := artPThread.Join(t);
        Tests.ExpectedBool(TRUE, ok, "Thread join should succeed", pass);
        Tests.ExpectedBool(TRUE, threadRan, "Thread procedure should run", pass)
    END;
    IF pass THEN Out.String(" OK") ELSE Out.String(" FAILED") END; Out.Ln;
    RETURN pass
END TestThread;

BEGIN
    Tests.Init(ts, "artPThread");
    Out.String("Running artPThread Tests..."); Out.Ln;
    
    Tests.Add(ts, TestSleep);
    Tests.Add(ts, TestMutex);
    Tests.Add(ts, TestCondVar);
    (* This test hangs without threads implemented - disabled for now. *)
    (* Tests.Add(ts, TestCondVarWaitSignal); *)
    Tests.Add(ts, TestThread);
    
    ASSERT(Tests.Run(ts));
    Out.String("artPThread Tests Completed."); Out.Ln;
END PThreadTest.
