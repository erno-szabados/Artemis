(**
    PThreadTest.Mod - Unit tests for MINIMAL artPThread module
    
    Copyright (C) 2025
    Released under The 3-Clause BSD License.
*)
MODULE PThreadTest;

IMPORT Tests, artPThread, Out, Clock := artClock;

VAR
    ts: Tests.TestSet;

PROCEDURE TestSleep(): BOOLEAN;
VAR pass : BOOLEAN;
    c : Clock.Clock;
BEGIN
    pass := TRUE;
    NEW(c);
    Clock.Get(c);
    Out.String("  TestSleep (s):"); Out.Int(c.minute, 0); Out.String(":"); Out.Int(c.second, 0); Out.Ln;
    
    Out.String("Sleeping for 2 seconds..."); Out.Ln;
    (* Simple test: Sleep should not crash and should take some time *)
    artPThread.Sleep(2000); (* Sleep for 10 milliseconds *)
    
    Clock.Get(c);
    Out.String("  TestSleep (s):"); Out.Int(c.minute, 0); Out.String(":"); Out.Int(c.second, 0); Out.Ln;
    
    (* Test with zero - should not crash *)
    artPThread.Sleep(0);
    
    (* Test with negative - should not crash *)
    artPThread.Sleep(-1);
    
    (* This test primarily checks if the call can be made without crashing *)
    Tests.ExpectedBool(TRUE, TRUE, "Sleep function calls completed", pass);
    RETURN pass
END TestSleep;

PROCEDURE TestMutex(): BOOLEAN;
VAR pass, result: BOOLEAN;
    mutex: artPThread.Mutex;
BEGIN
    pass := TRUE;
    Out.String("  TestMutex...");
    
    (* Test mutex creation *)
    mutex := artPThread.NewMutex();
    Tests.ExpectedBool(FALSE, mutex = NIL, "Mutex creation should succeed", pass);
    
    IF mutex # NIL THEN
        (* Test locking *)
        result := artPThread.Lock(mutex);
        Tests.ExpectedBool(TRUE, result, "Mutex lock should succeed", pass);
        
        (* Test unlocking *)
        result := artPThread.Unlock(mutex);
        Tests.ExpectedBool(TRUE, result, "Mutex unlock should succeed", pass);
        
        (* Test double lock/unlock *)
        result := artPThread.Lock(mutex);
        Tests.ExpectedBool(TRUE, result, "Second mutex lock should succeed", pass);
        
        result := artPThread.Unlock(mutex);
        Tests.ExpectedBool(TRUE, result, "Second mutex unlock should succeed", pass);
        
        (* Test TryLock on unlocked mutex *)
        result := artPThread.TryLock(mutex);
        Tests.ExpectedBool(TRUE, result, "TryLock should succeed on unlocked mutex", pass);

        (* Test TryLock on already locked mutex *)
        result := artPThread.TryLock(mutex);
        Tests.ExpectedBool(FALSE, result, "TryLock should fail on already locked mutex", pass);

        (* Unlock for cleanup *)
        result := artPThread.Unlock(mutex);
        Tests.ExpectedBool(TRUE, result, "Unlock after TryLock should succeed", pass);
        
        (* Clean up *)
        artPThread.FreeMutex(mutex);
        Tests.ExpectedBool(TRUE, mutex = NIL, "Mutex should be NIL after FreeMutex", pass)
    END;
    
    IF pass THEN Out.String(" OK") ELSE Out.String(" FAILED") END; Out.Ln;
    RETURN pass
END TestMutex;

BEGIN
    Tests.Init(ts, "artPThread");
    Out.String("Running artPThread Tests..."); Out.Ln;
    
    Tests.Add(ts, TestSleep);
    Tests.Add(ts, TestMutex);
    
    ASSERT(Tests.Run(ts));
    Out.String("artPThread Tests Completed."); Out.Ln;
END PThreadTest.
